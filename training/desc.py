import argparsefrom dataclasses import dataclass, fieldsimport osimport hashlibfrom datasets import registry as datasets_registryfrom foundations import descfrom foundations import hparamsfrom foundations.step import Stepfrom foundations import pathsfrom platforms.platform import get_platform@dataclassclass TrainingDesc(desc.Desc):    """The hyperparameters necessary to describe a training run"""        model_hparams: hparams.ModelHparams    dataset_hparams: hparams.DatasetHparams    training_hparams: hparams.TrainingHparams        @staticmethod    def name_prefix(): return 'train'    # @staticmethod    def hashname(self, type_str) -> str:        fields_dict = {f.name: getattr(self, f.name) for f in fields(self)}        if type_str == 'base':            hparams_strs = [str(fields_dict[k]) for k in sorted(fields_dict) if (isinstance(fields_dict[k], hparams.DatasetHparams) or isinstance(fields_dict[k], hparams.ModelHparams))]            hash_str = hashlib.md5(';'.join(hparams_strs).encode('utf-8')).hexdigest()            return f'base_{hash_str}'        elif type_str == 'train':            hparams_strs = [str(fields_dict[k]) for k in sorted(fields_dict) if                            isinstance(fields_dict[k], hparams.TrainingHparams)]            hash_str = hashlib.md5(';'.join(hparams_strs).encode('utf-8')).hexdigest()            return f'train_{hash_str}'        else:            raise ValueError('Invalid type string of hparam : {}'.format(type_str))    @staticmethod    def add_args(parser: argparse.ArgumentParser, defaults: 'TrainingDesc' = None):        hparams.DatasetHparams.add_args(parser, defaults=defaults.dataset_hparams if defaults else None)        hparams.ModelHparams.add_args(parser, defaults=defaults.model_hparams if defaults else None)        hparams.TrainingHparams.add_args(parser, defaults=defaults.training_hparams if defaults else None)        @staticmethod    def create_from_args(args: argparse.Namespace) -> 'TrainingDesc':        dataset_hparams = hparams.DatasetHparams.create_from_args(args)        model_hparams = hparams.ModelHparams.create_from_args(args)        training_hparams = hparams.TrainingHparams.create_from_args(args)                return TrainingDesc(model_hparams, dataset_hparams, training_hparams)        @property    def end_step(self):        iterations_per_epoch = datasets_registry.iterations_per_epoch(self.dataset_hparams)        return Step.from_str(self.training_hparams.training_steps, iterations_per_epoch)        @property    def train_outputs(self):        return datasets_registry.num_classes(self.dataset_hparams)        def run_path(self, replicate):        base_hash = self.hashname(type_str='base')        train_hash = self.hashname(type_str='train')        return os.path.join(get_platform().root, base_hash, train_hash, f'replicate_{replicate}')        @property    def display(self):        return '\n'.join([self.dataset_hparams.display, self.model_hparams.display, self.training_hparams.display])    def save_param(self, replicate, type_str):        if type_str != 'base' and type_str != 'train':            raise ValueError('Invalid parameter string {}'.format(type_str))        base_hash = self.hashname(type_str='base')        train_hash = self.hashname(type_str='train')        base_output_location = os.path.join(get_platform().root, base_hash)        train_output_location = os.path.join(base_output_location, train_hash, f'replicate_{replicate}')        if not get_platform().is_primary_process:            return        if not get_platform().exists(base_output_location):            get_platform().makedirs(base_output_location)        if type_str == 'train' and not get_platform().exists(train_output_location):            get_platform().makedirs(train_output_location)        fields_dict = {f.name: getattr(self, f.name) for f in fields(self)}        if type_str == 'base':            hparams_strs = [fields_dict[k].display for k in sorted(fields_dict) if (isinstance(fields_dict[k], hparams.DatasetHparams) or isinstance(fields_dict[k], hparams.ModelHparams))]            with get_platform().open(paths.params_loc(base_output_location, type_str), 'w') as fp:                fp.write('\n'.join(hparams_strs))        else:            hparams_strs = [fields_dict[k].display for k in sorted(fields_dict) if isinstance(fields_dict[k], hparams.TrainingHparams)]            with get_platform().open(paths.params_loc(train_output_location, type_str), 'w') as fp:                fp.write('\n'.join(hparams_strs))